---
title: 演进式架构：构建拥抱变化的基石
date: '2025-01-15'
description: 演进式架构与持续架构（Continuous Architecture）理念一脉相承，强调架构设计没有终点，而是一个伴随软件开发生命周期持续演进的过程。。
tags:
  - 入门
  - 前端
coverImage: /images/default-cover.jpg
link: https://soda.dhwass.store/%E7%9F%AD%E6%96%87/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E9%81%93/
---

## 1. 演进式架构：构建拥抱变化的基石

### 1.1 持续架构：拥抱变化，持续演进，与时俱进
演进式架构与持续架构（Continuous Architecture）理念一脉相承，强调架构设计没有终点，而是一个伴随软件开发生命周期持续演进的过程。

**核心原则**:
- 推迟关键决策
- 架构支持多种实现
- 关注质量属性
- 持续监控和评估
- 自动化一切可自动化

### 1.2 增量变更：化繁为简，步步为营，降低风险
通过将大型的架构调整分解为一系列小的、可控的变更，降低风险、提高效率，并在演进过程中更好地保护现有架构特征。

**增量变更的优势**:
- 降低风险
- 提高效率
- 持续改进
- 更易于理解和维护

### 1.3 适应度函数：量化评估，指引方向，客观公正
适应度函数（Fitness Function）用于评估架构在特定维度上的表现，例如性能、安全性、可靠性等。

**适应度函数的类型**:
- 原子（Atomic）与整体（Holistic）
- 触发式（Triggered）与持续式（Continuous）
- 静态（Static）与动态（Dynamic）
- 预设的（Intentional）和涌现的（Emergent）

**示例**:
- 排序函数的执行时间（原子、触发式、动态）
- 系统整体性能评分（整体、持续式、动态）
- 代码圈复杂度（原子、触发式、静态）

## 2. 团队组织与架构演进：康威定律及其逆定理的深远影响

### 2.1 职能型团队 vs. 特性团队：不同的沟通模式，不同的架构
**职能型团队的弊端**:
- 沟通成本高
- 协调困难
- 责任不清
- 不利于架构演进

**特性团队的优势**:
- 沟通效率高
- 协作更紧密
- 责任更明确
- 更利于架构演进

### 2.2 构建与目标架构相仿的团队：实践康威逆定理
通过调整团队的组织结构来影响软件架构的设计。

**示例**:
- 微内核架构：内核团队和插件团队
- 微服务架构：按业务领域或限界上下文组建团队
- 事件驱动架构：按事件处理流程组建团队

### 2.3 康威定律在不同场景下的应用
- 遗留系统重构
- 组织变革
- 开源项目

## 3. 构建演进式架构的实践指南：多维度、全方位的演进策略

### 3.1 增量变更的实施：构建、部署流水线与自动化
通过自动化构建、测试、部署流程，实现快速迭代、持续交付。

**部署流水线步骤**:
1. 代码提交
2. 静态代码分析
3. 单元测试
4. 构建
5. 集成测试
6. 组件测试
7. 原子适应度函数测试
8. 验收测试
9. 整体适应度函数测试
10. 部署到测试环境
11. 用户验收测试 (UAT)
12. 性能测试
13. 安全性测试
14. 部署到生产环境
15. 持续监控

### 3.2 数据库的演进：增量变更、迁移脚本与数据库版本控制
通过增量变更的策略，为每个变更编写迁移脚本和逆迁移脚本。

**数据库版本控制工具**:
- Flyway
- Liquibase

**数据库增量变更示例**:
- 迁移脚本 (V1__add_email_to_users.sql)
- 逆迁移脚本 (U1__add_email_to_users.sql)

### 3.3 架构迁移：从单体到微服务 - 分解、解耦、迁移
将单体架构迁移到微服务架构的步骤：
1. 识别共享模块
2. 分析模块依赖
3. 拆分依赖
4. 逐步迁移

### 3.4 不同架构风格的演进能力对比
| 架构风格 | 优点 | 缺点 | 演进能力 | 适用场景 |
| --- | --- | --- | --- | --- |
| 单体架构 | 开发、部署简单 | 可扩展性、可维护性差 | 差 | 小型应用、原型项目 |
| 分层架构 | 结构清晰、易于理解 | 层与层之间耦合度高、部署不够灵活 | 一般 | 中小型应用 |
| 微内核架构 | 可扩展性好、灵活性高 | 核心系统与插件之间的耦合、性能开销 | 较好 | 需要高度可定制化和可扩展性的应用，例如 IDE、操作系统 |
| 微服务架构 | 独立部署、独立扩展、技术多样性 | 分布式系统的复杂性、运维成本高 | 好 | 大型、复杂应用、需要快速迭代和持续交付的应用 |
| 事件驱动架构 | 松耦合、高可扩展性、异步处理 | 事件一致性难以保证、调试和监控比较复杂 | 好 | 需要处理大量异步事件的应用，例如物联网、实时数据处理 |
| SOA | 服务重用、松耦合 | 性能开销、ESB 成为单点故障 | 较差 | 企业级应用集成 |
| 无服务器架构 | 按需付费、自动扩展、无需管理服务器 | 厂商锁定、冷启动延迟、调试和监控比较复杂 | 好，但受限于平台 | 事件驱动型应用、API 网关、后台任务处理 |
| 组件化架构 | 代码复用率高 | 依赖管理复杂 | 根据组件的划分而变化 | 用户界面 |

### 3.5 其他实践指南
- 去除不必要的可变性
- 让决策可逆
- 控制架构量子的大小
- 选择合适的架构
- 避免过度工程化
- 持续学习和改进

---

**结语**  
演进式架构是一种重要的软件架构思想，它可以帮助我们构建更加灵活、可维护、可扩展的软件系统。通过理解演进式架构的核心概念、评估方法、不同架构风格的演进能力以及实践指南，我们可以更好地应对软件开发中的挑战，构建出更加优秀的软件产品。

---

**视频地址**: [深入浅出：软件架构的演进之道](https://www.bilibili.com/video/BV14QcBe1ECS/)